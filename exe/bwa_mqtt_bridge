#!/usr/bin/env ruby
# frozen_string_literal: true

require "sd_notify"
require "set"
require "json"
require "mqtt"                               # for direct publish
require "mqtt/homie/home_assistant"

require "bwa/logger"
require "bwa/client"
require "bwa/discovery"
require "bwa/version"

class MQTTBridge
  SIMPLE_PROPERTIES = %i[
    hold
    priming
    heating_mode
    twenty_four_hour_time
    heating
    temperature_range
    current_temperature
    target_temperature
  ].freeze
  private_constant :SIMPLE_PROPERTIES

  def initialize(mqtt_uri, bwa, device_id: "bwa", root_topic: "homie")
    Thread.abort_on_exception = true

    @mqtt_uri = mqtt_uri
    @homie = MQTT::Homie::Device.new(device_id, "BWA Link", mqtt: mqtt_uri, root_topic: root_topic)
    @bwa = bwa

    BWA.logger.warn "[BWA] Custom build with Bridge Connected + Climate discovery loaded"

    # Publish "bridge connected" entity/state right away (no spa required)
    publish_hass_bridge_connected_discovery
    publish_hass_bridge_connected_state("online")

    # Ensure we mark offline on clean exit
    at_exit { publish_hass_bridge_connected_state("offline") }

    # spin until we have a full configuration
    loop do
      message = @bwa.poll
      next if message.is_a?(BWA::Messages::Ready)

      if message.is_a?(BWA::Messages::Status)
        @bwa.request_control_info unless @bwa.control_configuration
        @bwa.request_control_info2 unless @bwa.configuration
        @bwa.request_filter_configuration unless @bwa.filter_cycles
      end

      break if @bwa.full_configuration?
    end

    @homie.home_assistant_device = {
      manufacturer: "Balboa Water Group",
      sw_version: BWA::VERSION,
      model: @bwa.model
    }

    publish_basic_attributes
    @homie.publish

    # Publish HA Climate discovery (retained)
    publish_hass_climate_discovery

    BWA.logger.warn "Balboa MQTT Bridge running (version #{BWA::VERSION})"
    SdNotify.ready

    loop do
      message = @bwa.poll
      next if message.is_a?(BWA::Messages::Ready)

      case message
      when BWA::Messages::FilterCycles
        2.times do |i|
          node = @homie["filter-cycle#{i + 1}"]
          node["start-hour"].value = message.public_send(:"cycle#{i + 1}_start_hour")
          node["start-minute"].value = message.public_send(:"cycle#{i + 1}_start_minute")
          node["duration"].value = message.public_send(:"cycle#{i + 1}_duration")
          node["enabled"].value = message.cycle2_enabled? if i == 1
        end
      when BWA::Messages::Status
        # keep spa time in sync
        now = Time.now
        now_minutes = (now.hour * 60) + now.min
        spa_minutes = (message.hour * 60) + message.minute
        diff = [(spa_minutes - now_minutes) % 1440, 1440 - ((spa_minutes - now_minutes) % 1440)].min
        if diff > 1
          spa_time_str = format("%02d:%02d", message.hour, message.minute)
          now_str = format("%02d:%02d", now.hour, now.min)
          BWA.logger.info "Spa time #{spa_time_str}, actually #{now_str}; correcting difference of #{diff} min"
          @bwa.set_time(now.hour, now.min, twenty_four_hour_time: message.twenty_four_hour_time)
        end

        if @bwa.temperature_scale != @homie["spa"]["temperature-scale"].value
          @homie.init do
            @homie["spa"]["temperature-scale"].value = @bwa.temperature_scale
            update_temperature_scale
            publish_hass_climate_discovery
          end
        end

        SIMPLE_PROPERTIES.each do |prop|
          property = @homie["spa"][prop.to_s.tr("_", "-")]
          property.value = @bwa.public_send(prop)
        end
        @homie["spa"]["notification"].value = @bwa.notification || "none"
        2.times do |i|
          @homie["filter-cycle#{i + 1}"]["running"].value = @bwa.status.filter_cycles[i]
        end

        @homie["spa"]["circulation-pump"].value = @bwa.circulation_pump if @bwa.configuration.circulation_pump
        case @bwa.configuration.blower
        when 0
          # not present
        when 1
          @homie["spa"]["blower"].value = !@bwa.blower.zero?
        else
          @homie["spa"]["blower"].value = @bwa.blower
        end
        @homie["spa"]["mister"].value = @bwa.mister if @bwa.configuration.mister

        @bwa.configuration.pumps.each_with_index do |speeds, i|
          next if speeds.zero?

          property = @homie["spa"]["pump#{i + 1}"]
          property.value = (speeds == 1) ? @bwa.pumps[i] != 0 : @bwa.pumps[i]
        end
        @bwa.configuration.lights.each_with_index do |exists, i|
          next unless exists
          @homie["spa"]["light#{i + 1}"].value = @bwa.lights[i]
        end
        @bwa.configuration.aux.each_with_index do |exists, i|
          next unless exists
          @homie["spa"]["aux#{i + 1}"].value = @bwa.lights[i]
        end

        SdNotify.watchdog
      end
    end
  end

  def publish_basic_attributes
    allow_toggle = lambda { |value| next value if value == "toggle" }
    allow_toggle_or_speed = lambda do |value|
      next value if value == "toggle"
      next true if value == "true"
      next false if value == "false"
      value.to_i if value.match?(/^\d+$/)
    end
    allowed_items = BWA::Messages::ToggleItem::ITEMS.keys.map(&:to_s)
    allow_toggles = ->(value) { next value if allowed_items.include?(value) }

    @homie.node("spa", "Hot Tub", @bwa.model) do |spa|
      command = spa.property("command",
        "Send a command to the tub",
        :enum,
        format: %w[normal_operation clear_notification soak],
        retained: false,
        non_standard_value_check: allow_toggles) { |value| @bwa.toggle_item(value.to_sym) }

      command.hass_button(name: "Clear Notification",  object_id: "clear_notification",  payload_press: "clear_notification")
      command.hass_button(name: "Normal Operation",    object_id: "normal_operation",    payload_press: "normal_operation")
      command.hass_button(name: "Soak",                object_id: "soak",                payload_press: "soak")

      spa.property("hold", "Hold", :boolean, @bwa.hold,
        hass: { switch: { icon: "mdi:pause-octagon" } },
        non_standard_value_check: allow_toggle) do |value|
        next @bwa.toggle_hold if value == "toggle"
        @bwa.hold = value
      end

      spa.property("priming", "Priming", :boolean, @bwa.priming, hass: { binary_sensor: { icon: "mdi:fast-forward" } })

      spa.property("notification", "Notification", :enum,
        @bwa.notification || "none",
        format: BWA::Messages::Status::NOTIFICATIONS.values.compact + ["none"])

      spa.property("heating-mode", "Heating Mode", :enum, @bwa.heating_mode,
        format: BWA::Client::HEATING_MODES,
        hass: { select: { icon: "mdi:cog-play" } },
        non_standard_value_check: allow_toggle) do |value|
        next @bwa.toggle_heating_mode if value == "toggle"
        @bwa.heating_mode = value.to_sym
      end

      spa.property("temperature-scale", "Temperature Scale", :enum, @bwa.temperature_scale,
        format: %w[fahrenheit celsius],
        hass: :select) { |value| @bwa.temperature_scale = value.to_sym }

      spa.property("twenty-four-hour-time", "24 Hour Time", :boolean, @bwa.twenty_four_hour_time?,
        hass: { switch: { icon: "mdi:timer-cog" } }) do |value|
        now = Time.now
        @bwa.set_time(now.hour, now.min, twenty_four_hour_time: value)
      end

      spa.property("heating", "Heating", :boolean, @bwa.heating?)
      @homie.mqtt.unpublish_hass_binary_sensor("spa_heating", node_id: @homie.id)

      spa.property("temperature-range", "Temperature Range", :enum, @bwa.temperature_range,
        format: %i[high low],
        hass: { select: { icon: "mdi:thermometer-lines" } },
        non_standard_value_check: allow_toggle) do |value|
        next @bwa.toggle_temperature_range if value == "toggle"
        @bwa.temperature_range = value.to_sym
      end

      spa.property("current-temperature", "Current Water Temperature", :float, @bwa.current_temperature)
      spa.property("target-temperature",  "Target Water Temperature",  :float, @bwa.target_temperature) { |value| @bwa.target_temperature = value }

      @homie.mqtt.unpublish_hass_sensor("spa_current-temperature", node_id: @homie.id)
      @homie.mqtt.unpublish_hass_sensor("spa_target-temperature",  node_id: @homie.id)

      update_temperature_scale

      unless @bwa.configuration.blower.zero?
        if @bwa.configuration.blower == 1
          args = [:boolean, !@bwa.blower.zero?]
          kwargs = { hass: { switch: { icon: "mdi:chart-bubble" } } }
        else
          args = [:integer, @bwa.blower]
          kwargs = { format: 0..@bwa.configuration.blower, hass: { number: { icon: "mdi:chart-bubble" } } }
        end
        spa.property("blower", "Blower", *args,
          non_standard_value_check: allow_toggle_or_speed, **kwargs) do |value|
          next @bwa.toggle_blower if value == "toggle"
          @bwa.blower = value
        end
      end

      if @bwa.configuration.mister
        spa.property("mister", "Mister", :boolean, @bwa.mister,
          hass: { switch: { icon: "mdi:sprinkler-fire" } },
          non_standard_value_check: allow_toggle) do |value|
          next @bwa.toggle_mister if value == "toggle"
          @bwa.mister = value
        end
      end

      if @bwa.configuration.circulation_pump
        spa.property("circulation-pump", "Circulation Pump Running", :boolean, @bwa.circulation_pump,
          hass: { binary_sensor: { device_class: :running, icon: "mdi:sync" } })
      end

      single_pump = @bwa.configuration.pumps.count { |speeds| !speeds.zero? } == 1
      @bwa.configuration.pumps.each_with_index do |speeds, i|
        next if speeds.zero?
        if speeds == 1
          args = [:boolean, !@bwa.pumps[i].zero?]
          kwargs = { hass: { switch: { icon: "mdi:chart-bubble" } } }
        else
          args = [:integer, @bwa.pumps[i]]
          kwargs = { format: 0..speeds, hass: { number: { icon: "mdi:chart-bubble" } } }
        end
        name = single_pump ? "Pump" : "Pump #{i + 1}"
        spa.property("pump#{i + 1}", name, *args,
          non_standard_value_check: allow_toggle_or_speed, **kwargs) do |value|
          next @bwa.toggle_pump(i) if value == "toggle"
          @bwa.set_pump(i, value)
        end
      end

      single_light = @bwa.configuration.lights.count(&:itself)
      @bwa.configuration.lights.each_with_index do |exists, i|
        next unless exists
        name = single_light ? "Lights" : "Lights #{i + 1}"
        spa.property("light#{i + 1}", name, :boolean, @bwa.lights[i],
          hass: { light: { icon: "mdi:car-parking-lights" } },
          non_standard_value_check: allow_toggle) do |value|
          next @bwa.toggle_light(i) if value == "toggle"
          @bwa.set_light(i, value)
        end
      end

      @bwa.configuration.aux.each_with_index do |exists, i|
        next unless exists
        spa.property("aux#{i + 1}", "Auxiliary #{i + 1}", :boolean, @bwa.aux[i],
          hass: :switch,
          non_standard_value_check: allow_toggle) do |value|
          next @bwa.toggle_aux(i) if value == "toggle"
          @bwa.set_aux(i, value)
        end
      end
    end

    2.times do |i|
      @homie.node("filter-cycle#{i + 1}", "Filter Cycle #{i + 1}", "Filter Cycle") do |cycle|
        cycle.property("running", "Running", :boolean, @bwa.status.filter_cycles[i],
          hass: { binary_sensor: { icon: "mdi:air-filter" } })
        cycle.property("start-hour", "Start Hour", :integer,
          @bwa.filter_cycles.public_send(:"cycle#{i + 1}_start_hour"),
          format: 0...24, unit: "hours",
          hass: { number: { icon: "mdi:clock" } }) { |value| update_filter_cycles(:"cycle#{i + 1}_start_hour", value) }
        cycle.property("start-minute", "Start Minute", :integer,
          @bwa.filter_cycles.public_send(:"cycle#{i + 1}_start_minute"),
          format: 0...60, unit: "minutes",
          hass: { number: { icon: "mdi:clock" } }) { |value| update_filter_cycles(:"cycle#{i + 1}_start_minute", value) }
        cycle.property("duration", "Duration", :integer,
          @bwa.filter_cycles.public_send(:"cycle#{i + 1}_duration"),
          format: 0...1440, unit: "minutes",
          hass: { number: { icon: "mdi:clock" } }) { |value| update_filter_cycles(:"cycle#{i + 1}_duration", value) }

        next unless i == 1
        cycle.property("enabled", "Enabled", :boolean, hass: { switch: { icon: "mdi:filter-check" } }) do |value|
          update_filter_cycles(:cycle2_enabled, value)
        end
      end
    end
  end

  def update_filter_cycles(prop, value)
    new_config = @bwa.filter_cycles.dup
    new_config.public_send(:"#{prop}=", value)
    @bwa.update_filter_cycles(new_config)
  end

  def update_temperature_scale
    @homie["spa"]["current-temperature"].unit =
      @homie["spa"]["target-temperature"].unit =
        "°#{@bwa.temperature_scale.to_s[0].upcase}"
    if @bwa.temperature_scale == :celsius
      @homie["spa"]["current-temperature"].format = 0..42
      @homie["spa"]["target-temperature"].format = 10..40
      @homie["spa"]["target-temperature"].hass_number(icon: "mdi:thermometer", step: 0.5)
    else
      @homie["spa"]["current-temperature"].format = 32..108
      @homie["spa"]["target-temperature"].format = 50..106
      @homie["spa"]["target-temperature"].hass_number(icon: "mdi:thermometer", step: 1)
    end

    @homie["spa"].hass_water_heater(
      current_temperature_property: "current-temperature",
      mode_property: "heating",
      modes: %i[off electric],
      mode_state_template: <<~JINJA,
        {% if value == 'true' %}
          electric
        {% elif value == 'false' %}
          off
        {% endif %}
      JINJA
      temperature_property: "target-temperature",
      icon: "mdi:hot-tub"
    )
    @homie["spa"]["current-temperature"].hass_sensor(device_class: :temperature)
  end

  # ---------- Helpers to publish via MQTT ----------
  def mqtt_publish(topic, payload, retain: false, qos: 1)
    BWA.logger.info "MQTT publish → #{topic} (retain=#{retain})"
    # First try a one-shot direct publish
    MQTT::Client.connect(@mqtt_uri) { |c| c.publish(topic, payload, retain, qos) }
  rescue => e
    BWA.logger.warn "Direct MQTT publish failed: #{e.class}: #{e.message}"
    # Fallback: try the Homie client's MQTT, if it exposes publish
    begin
      if @homie.respond_to?(:mqtt) && @homie.mqtt.respond_to?(:publish)
        @homie.mqtt.publish(topic, payload, retain: retain)
        BWA.logger.info "Fallback publish via Homie client succeeded → #{topic}"
      else
        raise "Homie MQTT client has no publish method"
      end
    rescue => e2
      BWA.logger.error "Fallback MQTT publish failed: #{e2.class}: #{e2.message}"
    end
  end

  # --- NEW: Publish Home Assistant MQTT Climate discovery (retained) ---
  def publish_hass_climate_discovery
    hass_prefix   = ENV["HASS_DISCOVERY_PREFIX"] || "homeassistant"
    dev_id        = @homie.id
    name          = "BWA Link"
    homie_base    = "homie/#{dev_id}/spa"
    availability  = "homie/#{dev_id}/$state"

    if @bwa.temperature_scale == :celsius
      min_temp = 10;  max_temp = 40; temp_step = 0.5
    else
      min_temp = 50;  max_temp = 106; temp_step = 1
    end

    payload = {
      name: "#{name} Climate",
      unique_id: "#{dev_id}_spa_climate",
      object_id: "spa",
      device: {
        identifiers: ["#{dev_id}_spa"],
        manufacturer: "Balboa Water Group",
        name: name,
        model: @bwa.model,
        sw_version: BWA::VERSION
      },
      availability: [
        { topic: availability, payload_available: "ready", payload_not_available: "lost" }
      ],
      modes: ["heat", "off"],
      mode_state_topic:   "#{homie_base}/heating-mode",
      mode_state_template:"{{ 'off' if (value | lower) == 'rest' else 'heat' }}",
      mode_command_topic: "#{homie_base}/heating-mode/set",
      mode_command_template: "{{ 'rest' if value == 'off' else 'ready' }}",
      current_temperature_topic: "#{homie_base}/current-temperature",
      temperature_state_topic:   "#{homie_base}/target-temperature",
      temperature_command_topic: "#{homie_base}/target-temperature/set",
      min_temp: min_temp,
      max_temp: max_temp,
      temp_step: temp_step,
      action_topic: "#{homie_base}/heating",
      action_template: "{{ 'heating' if value in ['true','True',true,1,'1','on','ON'] else 'idle' }}"
    }

    topic = "#{hass_prefix}/climate/#{dev_id}/spa/config"
    mqtt_publish(topic, payload.to_json, retain: true)
  rescue => e
    BWA.logger.warn "Failed to publish HA climate discovery: #{e.class}: #{e.message}"
  end

  # --- NEW: Bridge Connected binary_sensor (retained) ---
  def publish_hass_bridge_connected_discovery
    hass_prefix = ENV["HASS_DISCOVERY_PREFIX"] || "homeassistant"
    dev_id      = @homie.id
    name        = "BWA Link"

    payload = {
      name: "#{name} Bridge Connected",
      unique_id: "#{dev_id}_bridge_connected",
      object_id: "bridge",
      device_class: "connectivity",
      payload_on: "online",
      payload_off: "offline",
      state_topic: "bwa/#{dev_id}/bridge/connected",
      device: {
        identifiers: ["#{dev_id}_spa"],
        manufacturer: "Balboa Water Group",
        name: name,
        model: "MQTT Bridge",
        sw_version: BWA::VERSION
      }
    }

    topic = "#{hass_prefix}/binary_sensor/#{dev_id}/bridge/config"
    mqtt_publish(topic, payload.to_json, retain: true)
  rescue => e
    BWA.logger.warn "Failed to publish bridge connected discovery: #{e.class}: #{e.message}"
  end

  def publish_hass_bridge_connected_state(state)
    dev_id = @homie.id
    topic  = "bwa/#{dev_id}/bridge/connected"
    mqtt_publish(topic, state, retain: true)
  rescue => e
    BWA.logger.warn "Failed to publish bridge connected state: #{e.class}: #{e.message}"
  end
end

mqtt_uri = ARGV.shift

if ARGV.empty?
  spas = BWA::Discovery.discover
  if spas.empty?
    BWA.logger.fatal "Could not find spa!"
    warn "Could not find spa!"
    exit 1
  end
  spa_ip = "tcp://#{spas.first.first}/"
else
  spa_ip = ARGV[0]
end

spa = BWA::Client.new(spa_ip)

spa.request_configuration
spa.request_filter_configuration

MQTTBridge.new(mqtt_uri, spa)
